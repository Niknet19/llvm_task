# Лабораторная работа 7. Преобразование и анализ кода с использованием Clang и LLVM
## Установка и подготовка среды
Команда установки: `sudo apt install clang llvm`
![изображение](https://github.com/user-attachments/assets/6fa51ba4-496c-4213-9fff-f364ccee15b9)

## Код программы
```
#include <stdio.h>
int square(int x) {
return x * x;
}
int main() {
int a = 5;
int b = square(a);
printf("%d\n", b);
return 0;
}
```
## Получение AST
Команда: `clang -Xclang -ast-dump -fsyntax-only square.c`
Получили такое:
![изображение](https://github.com/user-attachments/assets/fea0c68e-616c-48ba-b6be-49fb6e17dc3a)

## Генерация LLVM IR
Команда: `clang -S -emit-llvm square.c -o square.ll`
![изображение](https://github.com/user-attachments/assets/58257d50-44ea-436c-9ef9-4e3ec58b3e87)
Полученное промежуточное представление:
![изображение](https://github.com/user-attachments/assets/277d29cb-eed5-4175-83db-438c206f3a94)

## Оптимизация IR
Команда: `clang -O0 -S -emit-llvm square.c -o square_O0.ll`
IR с оптимизацией O0:
![изображение](https://github.com/user-attachments/assets/7de7a88c-b701-466d-a24f-3823b327a9a6)
Нет отлчий от исходной версии:
![изображение](https://github.com/user-attachments/assets/9c3a0210-1409-4b26-84d4-adaa7c4bb794)

IR c оптимизацией O2:
![изображение](https://github.com/user-attachments/assets/7ca2c32a-bfd9-4b53-817f-c5febcfe38a3)

Отличия O0 и O2 оптимизаций:
![изображение](https://github.com/user-attachments/assets/8a947c00-04ad-458d-bec6-aa5bbb73b3f1)

## Граф потока управления программы
- Команда для генерации оптимизированного LLVM IR: `clang -O2 -S -emit-llvm square.c -o square.ll`
- Команда для генерации .dot-файлов CFG для функций: `opt -passes="dot-cfg" -disable-output square.ll`
- Установка graphviz для генерации .dot файлов: `sudo apt install graphviz`
![изображение](https://github.com/user-attachments/assets/6449c2e0-77c5-4b8c-885c-3357e1abf27e)

![изображение](https://github.com/user-attachments/assets/0178c274-4fdf-4d51-99a9-f03579d8cab1)

Команды для преобразования файлов с расширением .dot в .png с помощью Graphviz:
- `dot -Tpng .main.dot -o cfg_main.png`
- `dot -Tpng .square.dot -o cfg_square.png`
Команды для просмотра файлов с CGF:
- `xdg-open cfg_main.png`
  
Получили в итоге:

![cfg_main](https://github.com/user-attachments/assets/598f342b-fb19-465f-9583-59baab315568)

![cfg_square](https://github.com/user-attachments/assets/d3bcf6e7-ab2c-430a-b726-004ee18ebf83)

# Дополнительное задание

## Задание 
Напишите const double PI = 3.1415; и используйте в арифметике. Проанализируйте поведение с -constprop или -O2.

## Код
Напишем такой код:
```
#include <stdio.h>

double calculate() {
  const double pi = 3.1415;
  double radius = 10.0;
  double area = pi * radius * radius;  // Вычисление площади круга

  return area;
}

double test() {
  return 2.0 * 3.0;  // Должно стать 'ret double 6.0'
}

int main() {
  double result = calculate();
  printf("Result: %f\n", result);
  return 0;
}
```
## Компилируем IR
Сначала скомпилируем без оптимизаций: `clang -O0clang -O0 -S -emit-llvm const.c -o const_unoptimized.ll`

Получим такое IR:
![изображение](https://github.com/user-attachments/assets/d78f1925-d4e3-40ac-8e96-3ba198e0fb4c)


Теперь скомпилируем с оптимизацияеми уровня O2:
`clang -O2 -S -emit-llvm const.c -o const_optimized_O2.ll`

Получаем:
![изображение](https://github.com/user-attachments/assets/a6e6ed12-56c2-4351-aef5-b6b8ce4318f1)

## Выводы
Без оптимизации все вычисления происходят как написано в коде:
- Создаются три переменные на стеке (%1, %2, %3) для `pi`, `radius` и `area`.
- Константы 3.1415 и 10.0 сохраняются в память (store).
- Вычисления `pi * radius * radius` выполняются как две операции умножения (fmul):
- Результат сохраняется в %3 и затем загружается для возврата (ret).

### После оптимизации
```
define dso_local noundef double @calculate() local_unnamed_addr #0 {
  ret double 0x4073A26666666667
}
```
В функции calculate:
- Функция сократилась до одной инструкции: `ret double 0x4073A26666666667`.
- Значение 0x4073A26666666667 — это шестнадцатеричное представление числа с плавающей точкой, равное 314.15.
- Все промежуточные операции (alloca, store, load, fmul) исчезли.
- Компилятор распознал, что `pi` и `radius` это константы и произвел Constant Folding (Сворачивание констант).

В функции main:
```
define dso_local noundef i32 @main() local_unnamed_addr #1 {
  %1 = tail call i32 (ptr, ...) @printf(ptr noundef nonnull dereferenceable(1) @.str, double noundef 0x4073A26666666667)
  ret i32 0
}
```
- Вызов calculate исчез, а его результат (0x4073A26666666667) напрямую передан в printf (инлайнинг).
- После инлайнинга LLVM увидел, что calculate возвращает константу и подставил это значение в printf.

# Ответы на контрольные вопросы
### 1. Что такое Clang, и какова его роль в процессе компиляции программ?
Clang — это фронтенд-компилятор для языков C, C++, Objective-C и Objective-C++, разработанный как часть проекта LLVM. Его основная роль заключается в:

* Лексическом, синтаксическом и семантическом анализе исходного кода.
* Построении абстрактного синтаксического дерева (AST).
* Генерации LLVM IR (промежуточного представления) для дальнейшей обработки LLVM.
* Интеграции с инструментами статического анализа (например, Clang Static Analyzer).

Clang не выполняет оптимизацию и генерацию машинного кода — это задачи LLVM.

### 2. Что представляет собой LLVM и как он используется в современных компиляторах?
LLVM (Low-Level Virtual Machine) — это набор модульных и повторно используемых компонентов для компиляции. По сути это инфраструктура для создания компиляторов:
* Универсальное промежуточное представление (IR).
* Набор инструментов для оптимизации и генерации машинного кода.
* Поддержку множества архитектур (x86, ARM, RISC-V и тд).

Он используется для оптимизации, генерации и анализа промежуточного и машинного кода. Многие современные компиляторы (например, Rust, Swift, Clang) используют LLVM как бекенд, то есть для трансляции IR в исполняемый код.

### 3. Чем отличается абстрактное синтаксическое дерево (AST) от промежуточного представления LLVM IR?

- AST — это дерево, отражающее грамматическую структуру исходного кода на уровне языка программирования. Оно зависит от языка и используется для семантического анализа.
- LLVM IR — это низкоуровневое, но машинно-независимое представление, ориентированное на оптимизацию и генерацию кода. Оно оптимизируется и преобразуется в машинный код.

### 4. Для чего необходимо промежуточное представление (IR) в процессе компиляции?
- Разделение фронтенда и бэкенда:
Фронтенд работает только до генерации IR.
Бэкенд оптимизирует IR и генерирует код под разные платформы.
- Упрощение оптимизаций: Единое представление для всех языков.
- Переносимость: IR можно компилировать под любую поддерживаемую архитектуру.

### 5. Что делает инструкция alloca в LLVM IR, и зачем она используется в функциях?
Инструкция alloca (allocate) выделяет память на стеке функции. Она используется для создания локальных переменных внутри функции. Эта память автоматически освобождается при выходе из функции.
%ptr = alloca i32 — выделяет память в стеке функции для переменной (аналог int x; в C).

### 6. Зачем нужна оптимизация кода в компиляторе, и какие основные цели она преследует?
Цель оптимизации:
- Повышение производительности кода;
- Уменьшение размера исполняемого файла;
- Снижение энергопотребления;
- Улучшение параллелизма и использование аппаратных возможностей.

### 7. Что такое SSA-форма и почему она важна при оптимизации программ?
SSA - промежуточное представление, используемое компиляторами, в котором каждой переменной значение присваивается лишь единожды. Это упрощает анализ и оптимизацию кода, так как компилятор может легко отслеживать зависимости между значениями.
- Позволяет легко находить мёртвый код (если %x1 нигде не используется после %x2, его можно удалить).
- Легко определить, где используется значение (нет "размазывания" одной переменной через несколько изменений).
- Улучшение условий для оптимизаций, таких как constant propagation и инлайнинг.

### 8. Что такое граф потока управления (CFG) и как он помогает анализировать поведение программы?
CFG (Control Flow Graph) — это граф, где узлы — базовые блоки (последовательности инструкций без ветвлений), а ребра — возможные переходы управления между ними,  множество всех возможных путей исполнения программы, представленное в виде графa.
Он позволяет:
- Анализировать циклы и условия;
- Выявлять мертвый код;
- Применять локальные и глобальные оптимизации.

### 9. Как устроено представление арифметических операций в LLVM IR (например, умножение, сложение)?
В LLVM IR арифметические операции представлены в виде инструкций низкоуровневого трёхадресного кода, где каждый оператор принимает два операнда и возвращает результат в новую переменную.
`%result = <операция> <тип> <операнд1>, <операнд2>`
%result — имя виртуального регистра (SSA-переменная);
<операция> — ключевое слово LLVM (например, add, mul);
<тип> — тип операндов (например, i32, float);
<операнд1> и <операнд2> — значения, с которыми выполняется операция (могут быть переменные или константы).
Например сложение и умножение : `%res = add i32 %a, %b`, `%b = sub i32 %a, 5`

###  10. Почему функции в LLVM IR обычно представляют собой отдельные единицы анализа и оптимизации?
- Изолированность: Функцию можно оптимизировать независимо от других (у каждой функции свой стек).
- Инлайнинг: Короткие функции могут быть встроены в вызывающий код.
- Делает возможным локальный анализ без необходимости учитывать глобальный контекст
- Независимая и параллельная оптимизация

### 11. Что происходит с функцией в LLVM IR, если она вызывается один раз и очень короткая?

Происходит инлайнинг — тело функции вставляется в точку вызова, чтобы убрать накладные расходы на вызов.
Затем LLVM удалит функцию, если оригинальная функция больше нигде не используется (dead function elimination).

###  12. Какие преимущества даёт использование IR и CFG для автоматических оптимизаций по сравнению с анализом исходного текста на C?
- Формат IR проще и однозначнее, чем C
- IR абстрагируется от деталей языка : оптимизации могут применяться универсально для любых языков, транслируемых в IR.
-  IR и CFG упрощают применение сложных оптимизаций
-  IR ближе к машинному коду, но ещё независим от архитектуры : это позволяет делать низкоуровневые оптимизации, которые невозможно или очень трудно выполнить на C
-  CFG позволяет формально анализировать поток управления : в C напрямую построить такой граф сложнее из-за наличия различных конструкций (например goto)
